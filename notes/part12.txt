1234567890---------2---------3---------4---------5---------6---------7-2-------8---------9---------1
SVENs GITHUB: https://github.com/ofcan/game-of-life-ruby
MY PLAYLIST:  https://www.youtube.com/playlist?list=PLMC91Ry9EhRKUn0MIdgXrZiptF7nVyYoQ
MY GITHUB:    https://github.com/mixelpixel/GameOfLife
**A Ruby Tutorial: Implementing John H. Conway's "Game of Life"**
PART 12 - Four Rules finished!
https://youtu.be/vmSCB9IdDnk?list=PLMC91Ry9EhRKUn0MIdgXrZiptF7nVyYoQ


Completing the Four Rules:
RULE #2:

My thinking with this test (based on Rule #1 test) is that cell [0, 1] is alive and being tested for neighbors.
Not sure if when I start this [0, 1] is alive to start with...

# spec
146     context 'Rule 2: Any live cell with two or three live neighbours lives on to the next generation.' do
147       it 'should keep alive a cell with two or three neighbors' do
148 
149       # TWO neighbors
150         game = Game.new(world, [[0, 0], [0, 1], [0, 2]])
151         game.tick!
152         expect(world.cell_grid[0][1]).to be_alive
153 
154       # THREE neighbors
155         game = Game.new(world, [[0, 0], [0, 1], [0, 2], [1, 1]])
156         game.tick!
157         expect(world.cell_grid[0][1]).to be_alive
158 
159       end
160     end

# game
 15   def tick!
 16     world.cells.each do |cell|
 17       # Rule 1
 18       if cell.alive && world.live_neighbors_around_cell(cell).count < 2
 19         cell.die!
 20       end
 21       # Rule 2
 22       if cell.alive && ([2, 3].include? world.live_neighbors_around_cell(cell).count)
 23         cell.revive!                                              # < -- need to make this method
 24       end
 25     end
 26   end

# spec
 84   context 'Cell' do
 85     subject { Cell.new }
 86 
 87     it 'should create a new cell object' do
 88       expect(subject.is_a?(Cell)).to be_truthy
 89     end
 90 
 91     it 'should respond to proper methods' do
 92       expect(subject).to respond_to(:alive)
 93       expect(subject).to respond_to(:x)
 94       expect(subject).to respond_to(:y)
 95       expect(subject).to respond_to(:alive?)
 96       expect(subject).to respond_to(:die!)
 97       expect(subject).to respond_to(:revive!)      # <-- it's alive!!!!
 98    end

# game
113 class Cell
114   attr_accessor :alive, :x, :y
115 
116   def initialize(x=0, y=0)
117     @alive = false
118     @x = x
119     @y = y
120   end
121 
122   def alive?; alive; end
123 
124   def dead?; not alive; end
125 
126   def die!
127     @alive = false
128   end
129 
130   def revive!                           # < -- it's alive, ALIVE!!!!
131     @alive = true
132   end
133 
134 end



... after struggling with this awhile, i peeked at the lesson and realized there was more work to be 
done to get the first rule set up correctly so that it doesn't kill cells w/2 neighbors
(and kills cells with 0 neighbors)...









